<html><head><style>body {
   color: black;
}
</style></head><body><h1 id="inside-pi-apps-everything-a-power-user-should-know">Inside Pi-Apps: everything a power-user should know</h1>
<p>This guide will attempt to explain how Pi-Apps works. By nature, this cannot be complete, so feel free to look through the scripts yourself and ask the Pi-Apps developers questions.</p>
<h2 id="table-of-contents">Table of contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#the-app-folder">The app-folder</a></li>
<li><a href="#the-main-pi-apps-folder">The main Pi-Apps folder</a></li>
<li><a href="#the-app-status-folder">The App Status folder</a></li>
<li><a href="#the-manage-script">The <code>manage</code> script</a></li>
<li><a href="#the-pkg-install-script">The <code>pkg-install</code> script</a></li>
<li><a href="#the-updater-script">The <code>updater</code> script</a></li>
<li><a href="#the-api-script">The <code>api</code> script</a></li>
<li><a href="#the-gui-script">The <code>gui</code> script</a></li>
<li><a href="#the-createapp-script">The <code>createapp</code> script</a></li>
<li><a href="#the-settings-script">The <code>settings</code> script</a></li>
<li><a href="#the-preload-script">The <code>preload</code> script</a></li>
<li><a href="#the-preload-daemon-script">The <code>preload-daemon</code> script</a></li>
<li><a href="#the-terminal-run-script">The <code>terminal-run</code> script</a></li>
<li><a href="#the-categoryedit-script">The <code>categoryedit</code> script</a></li>
<li><a href="#the-logviewer-script">The <code>logviewer</code> script</a></li>
<li><a href="#the-viewlog-script">The <code>viewlog</code> script</a><h1 id="how-pi-apps-works">How Pi-Apps works</h1>
<h2 id="introduction">Introduction</h2>
</li>
<li>Pi-Apps is written in <strong><code>bash</code></strong>. This is a scripting language for Linux, with origins in the 80s. Bash is not a compiled language like C, it&#39;s an interpreted language, similar to Python and Windows .bat files.<br>Bash serves a different purpose than a compiled language: orchestrating OS-level events and prioritizing programming-time over execution-time. It is system-dependent and architecture-dependent.<br>You probably interact with <code>bash</code> without even realizing it! Nearly all Linux distributions today use a <strong>bash terminal</strong>. <em>If you have ever opened a terminal, you have interacted with bash.</em></li>
<li>Pi-Apps is comprised of <strong>bash scripts</strong>. These are text files that are filled with bash commands. To illustrate this, you can often <em>open</em> a bash script, <em>copy</em> the contents, and <em>paste</em> it into a bash terminal. And it will work exactly the same as if you executed the file! In fact, if Pi-Apps was reorganized into a single standalone bash script, you could <em>copy and paste the entire thing</em> into a terminal and have a working app store!</li>
<li>If Pi-Apps is only bash scripts, <strong>how does it display a GUI</strong>? (graphical user interface) Good question. When Pi-Apps was just a concept, I knew that bash was the obvious choice for installing apps. And that makes sense: if you normally install an application by running commands in a <em>bash-terminal</em>, it only makes sense to use a <em>bash-script</em>.<br>Bash was the best choice for installing apps, but what about the GUI? Most GUIs are made in C, C++, Python or JavaScript with GTK, Qt, or Electron. These were workable options, but for long-term maintainability and convenience I wanted to only use <strong>one language for the whole thing</strong>. Someone suggested <code>zenity</code> - a simple dialog program meant for bash scripts. I tried it, but was soon frustrated by its limitations. Then I discovered <strong><code>yad</code></strong> - an improved version of zenity with many more options. Pi-Apps uses <code>yad</code> for everything.<h2 id="the-app-folder">The app-folder</h2>
It makes sense to start here. After all, what is an app store without apps?<br>Basically, for every app, there is a <strong>folder</strong>. This folder is called an &quot;<strong>app-folder</strong>&quot;. On a default pi-apps installation, all app-folders are located in <code>/home/pi/pi-apps/apps</code>.<br>The folder&#39;s name is the app&#39;s name. The Arduino app is a folder located at <code>apps/Arduino</code>.<br>There are a few files in each app-folder:</li>
<li><code>install</code> - This is a bash script to install the app.<ul>
<li>Naming the script &quot;install&quot; indicates that it is compatible with 32-bit and 64-bit CPU architectures.</li>
</ul>
</li>
<li><code>install-32</code> - This is a bash script to install the app on 32-bit operating systems.<ul>
<li>Naming the script &quot;install-32&quot; indicates that it is designed for the 32-bit CPU architecture only.</li>
<li>If no &quot;install-64&quot; script exists, <strong>then this app will only be displayed on 32-bit systems.</strong></li>
</ul>
</li>
<li><code>install-64</code> - This is a bash script to install the app on 64-bit operating systems.<ul>
<li>Naming the script &quot;install-64&quot; indicates that it is designed for the 64-bit CPU architecture only.</li>
<li>If no &quot;install-32&quot; script exists, then <strong>this app will only be displayed on 64-bit systems.</strong></li>
</ul>
</li>
<li><code>uninstall</code> - This is a bash script to uninstall the app.</li>
<li><code>icon-24.png</code> and <code>icon-64.png</code> - These are the app&#39;s icons.</li>
<li><code>description</code> - This is a text file to explain what the app is, how it works, and why anybody would want it.<ul>
<li>The first line of this file is used as the <strong>tooltip</strong> (mouse hover-text) in the list of apps.</li>
</ul>
</li>
<li><code>credits</code> - This is a text file to give credit to the person who made the app.</li>
<li><code>website</code> - This is a text file containing the website URL of a given project.<ul>
<li>Usually it points to a website where users can learn more about the app.<h2 id="the-main-pi-apps-folder">The main Pi-Apps folder</h2>
The Pi-Apps folder contains several main subfolders. These folders have special characteristics and are treated differently during updates.</li>
</ul>
</li>
<li>The <code>data</code> folder and <code>logs</code> folder contain files that should <strong><em>never be updated</em></strong>. They contains settings, cached files, app-status files, log files, etc.</li>
<li>The <code>apps</code> folder contains apps. During an update it this folder is handled differently too.</li>
<li>Other folders like <code>icons</code> and <code>etc</code> are handled the same as individual files in the main pi-apps folder. <h2 id="the-app-status-folder">The App Status folder</h2>
Pi-Apps keeps track of each app&#39;s status: installed or uninstalled. (as well as a few other possible values)<br>Each app&#39;s status is located in the <code>data/status</code> folder.<br>For example, on a default Pi-Apps installation, the status file for <strong>arduino</strong> is located at: <code>/home/pi/pi-apps/data/status/Arduino</code>.<br>Each file in this folder will contain one of these possible values:</li>
<li><code>installed</code> - The app is currently installed.</li>
<li><code>uninstalled</code> - The app is currently uninstalled.</li>
<li><code>corrupted</code> - The app failed to install/uninstall.</li>
<li><code>disabled</code> - The app is in a disabled state: it will not be installed under any circumstances. <ul>
<li>This status is useful for TwisterOS where Box86 comes pre-installed. We don&#39;t want Pi-Apps installing Box86 under any circumstances, even if another app requires it to be installed.</li>
</ul>
</li>
</ul>
<p>As mentioned earlier, Pi-Apps runs on bash scripts. Each script has a certain job to do, and together they make Pi-Apps work.<br>Below is a concise explanation for how each script works:</p>
<h2 id="the-manage-script">The <code>manage</code> script</h2>
<h4 id="location-">Location:</h4>
<p>On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/manage</code>. </p>
<h4 id="purpose-">Purpose:</h4>
<p>The <code>manage</code> script will install apps, uninstall apps, and update apps. It can be compared to the <code>apt</code> tool on Debian Linux.</p>
<h4 id="usage-">Usage:</h4>
<p>The manage script won&#39;t do much if you run it standalone:</p>
<pre><code>$ ~/<span class="hljs-literal">pi</span>-apps/manage
You need <span class="hljs-built_in">to</span> specify <span class="hljs-keyword">an</span> operation, <span class="hljs-keyword">and</span> <span class="hljs-keyword">in</span> most cases, which app <span class="hljs-built_in">to</span> operate <span class="hljs-keyword">on</span>.
</code></pre><p>You need to tell the <code>manage</code> script to <em>do</em> something.</p>
<pre><code><span class="hljs-variable">$ </span>~<span class="hljs-regexp">/pi-apps/manage</span> install Arduino
</code></pre><p>Now we&#39;re getting somewhere! You just installed the Arduino app.
The <code>manage</code> script supports these <strong>modes</strong>:</p>
<ul>
<li><code>install</code>: installs the specified app.
Several things occur before the app&#39;s installation script is run:<ul>
<li>The specified app must exist.</li>
<li>The app must not be disabled. If it is, the <code>manage</code> script exits with an exit-code of zero.</li>
<li>If your system is unsupported (determined by the <code>is_supported_system</code> function in the api script), a warning will appear, along with a 10-second wait-time.</li>
<li>The app&#39;s installation script is determined. Depending on the app and on your system&#39;s CPU architecture, the script-name may be &quot;<code>install</code>&quot;, &quot;<code>install-32</code>&quot;, or &quot;<code>install-64</code>&quot;.</li>
<li>Determine a unique filename for the log-file to be generated. (This file will store the entire output of the installation process.)</li>
<li>Finally, the app&#39;s installation script is executed.<ul>
<li>It is executed with the <code>nice</code> command, to lower the priority of the process so that the rest of the system remains responsive, even while compiling.</li>
<li>Its output is redirected to the log-file, <em>and</em> to stdout. (usually the terminal)</li>
</ul>
</li>
<li>If the app&#39;s installation script <strong>succeeded</strong> (if it exited with a return code of <code>0</code>):<ul>
<li>The the log-file is renamed to <code>install-success-$app</code></li>
<li>The <code>manage</code> script exits with a return code of <code>0</code>.</li>
</ul>
</li>
<li>However, if the app&#39;s installation script failed (any return code except <code>0</code>):<ul>
<li>The the log-file will be renamed to <code>install-fail-$app</code>.</li>
<li>The <code>manage</code> script exits with a return code of <code>1</code>.</li>
</ul>
</li>
</ul>
</li>
<li><code>uninstall</code>: exactly like the <code>install</code> mode except that it uninstalls the specified app.<ul>
<li>These two modes are so similar that they share the same code!</li>
</ul>
</li>
<li><code>install-if-not-installed</code>: Installs the specified app, only if it has not already been installed.<ul>
<li>This mode is especially useful for apps that <strong>need another app to be installed first</strong>.
For example, the <strong><code>Wine (x86)</code></strong> app requires Box86. It accomplishes that with this comand:<pre><code class="lang-bash"><span class="hljs-string">"${DIRECTORY}/manage"</span> install-<span class="hljs-keyword">if</span>-<span class="hljs-keyword">not</span>-installed Box86 || <span class="hljs-keyword">error</span> <span class="hljs-string">"Box86 failed to install somehow!"</span>
</code></pre>
</li>
</ul>
</li>
<li><code>multi-install</code>: installs multiple apps, one at a time. How to specify multiple apps? By using a <strong><em>multi-line argument</em></strong>, like this:<pre><code class="lang-bash"><span class="hljs-variable">$ </span>~<span class="hljs-regexp">/pi-apps/manage</span> multi-install <span class="hljs-string">"Arduino
BalenaEtcher
CloudBuddy
Downgrade Chromium"</span>
</code></pre>
Note about <code>multi-install</code>: This mode includes 
elements.<ul>
<li>Before installing anything, <code>manage</code> will check if any apps are <strong>already installed</strong>. If so, a <code>yad</code> dialog will appear and ask if you <em>really</em> want to install that app again.<ul>
<li>If you choose &quot;No&quot;, the app is removed from the list of apps to install.</li>
</ul>
</li>
<li>Then, each app will be installed, one at a time.<ul>
<li>It does this by running the manage script in the <code>install</code> mode, once for each app</li>
</ul>
</li>
<li>If any apps fail to install, a <code>yad</code> dialog will appear and ask permission to send the error log to Pi-Apps developers.</li>
</ul>
</li>
<li><code>multi-uninstall</code>: exactly like <code>multi-install</code> except that it uninstalls the list of apps.<ul>
<li>These two modes are so similar that they share the same code!</li>
</ul>
</li>
<li><code>check-all</code>: This mode is the Pi-Apps equivalent to an <code>apt update</code>. It lists updatable apps.<ul>
<li>It downloads the latest pi-apps repository to the <code>update/pi-apps</code> folder. (using <code>git clone</code> or <code>git pull</code>, as appropriate) Now, there are two versions of Pi-Apps on the local filesystem: the &quot;<strong>local version</strong>&quot; and the &quot;<strong>latest version</strong>&quot;.</li>
<li>Each app-folder is compared.<ul>
<li>If the app-folder <strong><em>only</em></strong> exists in the local version, then no action is taken.</li>
<li>If the app-folder <strong><em>only</em></strong> exists in the online version, then it must be a new app and is added to the list of updatable apps.</li>
<li>If the app-folder exists in both locations and the <strong>contents do match</strong>, then no action is taken.</li>
<li>If the app-folder exists in both locations but the <strong>contents don&#39;t match</strong>, the online version must have received an update. As a result, the app is added to the list of updatable apps.</li>
</ul>
</li>
<li>Finally, the list of updatable apps (one app per line) is written to standard output and the script exits.</li>
</ul>
</li>
<li><code>update</code>: This mode will update a single app. (like an <code>apt upgrade</code>)
It copies the new version from the update folder to the main folder, reinstalling if necessary.<ul>
<li>First, the app may need to be installed, or it may not:<ul>
<li>If the app is currently installed, <em>and</em> its current installation script does not match the online version, then the app is uninstalled.</li>
</ul>
</li>
<li>Then the current (old) app-folder is sent to the system&#39;s <strong>Trash</strong> folder.<ul>
<li>This is a failsafe: just in case you made changes to the app-folder, you have an option to restore those changes. (as opposed to permanent deletion)</li>
</ul>
</li>
<li>The app-folder is copied from the <code>update/pi-apps/apps</code> folder to the main <code>apps</code> folder.</li>
<li>If the app was uninstalled earlier, it will now be installed back.</li>
</ul>
</li>
<li><code>update-all</code>: This mode will check for app-updates and install them without any user-interaction.
The <code>manage</code> script will run itself in the <code>check-all</code> mode, then, for every app that <code>check-all</code> mentioned, it will <code>update</code> each app.</li>
</ul>
<h2 id="the-pkg-install-script">The <code>pkg-install</code> script</h2>
<h4 id="location-">Location:</h4>
<p>On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/pkg-install</code>. </p>
<h4 id="purpose-">Purpose:</h4>
<p>Some background information first:  </p>
<ul>
<li>Goal: Pi-Apps is designed for people who install an app, try it out, then later uninstall it. You should not have to think twice before installing an app. Users should have confidence that <strong>uninstalling the app will undo all changes and restore all disk-space.</strong></li>
<li>Problem: Many apps need to install apt <strong>packages</strong> in order to work. On the surface, this does not seem like a big problem at all: if &quot;app1&quot; installs &quot;package1&quot;, &quot;package2&quot;, and &quot;package3&quot;, then those packages should be purged while uninstalling &quot;app1&quot;. What&#39;s the problem with that? <strong>Dependencies.</strong><br>What if some other utility requires &quot;package1&quot; to function? Now that you uninstalled &quot;app1&quot;, &quot;package1&quot; just got uninstalled.<ul>
<li>Best-case scenario: that utility will not work anymore.</li>
<li>Worst-case scenario: you just broke an essential part of your system and it will fail to boot.</li>
</ul>
</li>
<li>Solution: When uninstalling an app, <strong>only remove packages that are not required by anything else</strong>. To accomplish this, we can&#39;t just install packages the normal way with <code>sudo apt install</code>. Instead, we need to generate a <strong>dummy deb</strong> - a custom apt package that lists &quot;package1&quot;, &quot;package2&quot;, and &quot;package3&quot; as <strong>dependencies</strong>. Later, when the app is being uninstalled, the dummy deb is removed and a simple <code>apt autoremove</code> is enough to safely remove the packages.<h4 id="usage-">Usage:</h4>
In an app&#39;s <code>install</code> script, there may be a line like this to install &quot;package1&quot;, &quot;package2&quot;, and &quot;package3&quot;:<pre><code class="lang-bash">DIRECTORY=$HOME/pi-apps
<span class="hljs-string">"<span class="hljs-subst">${DIRECTORY}</span>/pkg-install"</span> <span class="hljs-string">'package1 package2 package3'</span> <span class="hljs-string">"$(dirname "</span>$0<span class="hljs-string">")"</span> || <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
</code></pre>
This is equivalent to:<pre><code class="lang-bash">sudo apt <span class="hljs-keyword">update</span> <span class="hljs-comment">--allow-releaseinfo-change</span>
sudo apt <span class="hljs-keyword">install</span> -yf <span class="hljs-comment">--no-install-recommends --allow-downgrades package1 package2 package3</span>
</code></pre>
<h4 id="how-it-works-">How it works:</h4>
</li>
<li>First, <code>pkg-install</code> sets the language variables to <code>C</code>. This ensures that apt&#39;s output is parsed correctly, even if the system is using a different language,</li>
<li><code>pkg-install</code> runs <code>sudo apt update</code>.</li>
<li>The output of <code>sudo apt update</code> is parsed for various messages from <code>apt</code>.<ul>
<li>If the output contains &quot;autoremove to remove them&quot;, you will receive a message that some packages can be removed with <code>apt autoremove</code>.</li>
<li>If the output contains &quot;packages can be upgraded&quot;, you will receive a message that some packages can be upgraded.</li>
<li>If the output contains &quot;W:&quot; or &quot;E:&quot; or &quot;Err:&quot;, <code>pkg-install</code> will <strong>exit with an error</strong> saying that your apt system is messed up.
The exact error message depends on apt&#39;s exact output - it is designed to help users navigate through apt errors and provides instructions for how to sign a repository, remove a broken repository, or check for an Internet connection.</li>
</ul>
</li>
<li>If any filenames (paths to a local deb package) are specified, <code>pkg-install</code> will install each one, then mark it as autoremovable. (Using this command: <code>sudo apt-mark auto &quot;$packagename&quot;</code></li>
<li>If any package names include <strong>regular expression</strong>, <code>pkg-install</code> expands the names with <code>apt-cache search</code>.</li>
<li>Finally, the dummy deb is created. As mentioned earlier, this package will list the desired packages as dependencies.<ul>
<li>The dummy deb for each app has to be named something unique. But this poses a problem because apps can have space characters while apt does not support space characters.</li>
<li>This problem is resolved by naming each dummy-deb based on a <strong>hash of its name</strong>.</li>
<li>The code used to do this is:<pre><code class="lang-bash"><span class="hljs-attribute">echo</span> -n <span class="hljs-string">'pi-apps-'</span> ; <span class="hljs-attribute">echo</span> <span class="hljs-string">"<span class="hljs-variable">$app</span>"</span> | md5sum | cut -c1-<span class="hljs-number">8</span> | awk <span class="hljs-string">'{print <span class="hljs-variable">$1</span>}'</span>
</code></pre>
</li>
<li>Feel free to replace <code>&quot;$app&quot;</code> with an app-name of your choice to see what its package name would be.</li>
</ul>
</li>
<li>If the dummy deb&#39;s name is already installed, purge it and then continue.</li>
<li>Finally, the dummy deb is installed with <code>apt</code>. All packages mentioned in the &quot;<code>Depends:</code>&quot; field of the dummy deb are installed as a dependency of the dummy deb.</li>
<li>If apt fails, its errors are diagnosed in the same way errors were diagnosed earlier when <code>sudo apt update</code> was run.</li>
<li><code>pkg-install</code> exits with a code of <code>0</code> if everything was successful, otherwise it exits with a code of <code>1</code>.<h3 id="the-purge-installed-script">The <code>purge-installed</code> script</h3>
<h4 id="location-">Location:</h4>
On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/purge-installed</code>. <h4 id="purpose-">Purpose:</h4>
This script is the opposite of <code>pkg-install</code>: it uninstalls the dummy deb, then runs <code>sudo apt autoremove</code>.<h4 id="usage-">Usage:</h4>
In an app&#39;s <code>uninstall</code> script, there may be a line like this:<pre><code class="lang-bash">DIRECTORY=$HOME/pi-apps
<span class="hljs-string">"<span class="hljs-subst">${DIRECTORY}</span>/purge-installed"</span> <span class="hljs-string">"$(dirname "</span>$0<span class="hljs-string">")"</span> || <span class="hljs-keyword">exit</span> <span class="hljs-number">1</span>
</code></pre>
<h2 id="the-updater-script">The <code>updater</code> script</h2>
<h4 id="location-">Location:</h4>
On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/updater</code>. <h4 id="purpose-">Purpose:</h4>
This script handles Pi-Apps updates, both for apps and for files. Apps do not have version numbers, so updating involves comparing the installation-script of the existing app-folder with the installation-script of the new app-folder.<h4 id="usage-">Usage:</h4>
<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/updater gui
</code></pre>
This will check for updatable apps and files, then will display them in a graphical list, (using <code>yad</code> of course), and will give you the option to update certain items and not others.<br>But that&#39;s not all you can do with this script. The <code>updater</code> script supports multiple <strong>modes</strong>, useful for a variety of situations:</li>
<li><code>gui</code> - Check for updates and list them graphically.<ul>
<li>This is the <strong>default mode</strong> if you did not specify one.</li>
<li>If you choose to update anything, a <strong>terminal</strong> will appear to update apps.</li>
</ul>
</li>
<li><code>gui-yes</code> - Exactly the same as the <code>gui</code> mode, except that the updates are automatically applied in a terminal.</li>
<li><code>autostarted</code> or <code>onboot</code> - This mode is intended to be <strong>run on boot</strong>.<ul>
<li>First, determine if the <strong>update-interval</strong> setting allows an update-check today.<ul>
<li>If not, the script exits.</li>
</ul>
</li>
<li>Then, make sure that <strong>at least one app has been installed</strong>.<ul>
<li>This is accomplished by checking if there are any files in the <code>data/status</code> folder.
A fresh installation of Pi-Apps will not have any files in that folder, because no apps have been installed yet.</li>
<li>If there are no files in that folder, the script will exit.</li>
</ul>
</li>
<li>After that, assuming there are updates available, display a <strong>notification</strong> in the lower-right corner of the screen.<ul>
<li>This notification is designed to not interfere with <strong>typing</strong>.</li>
</ul>
</li>
<li>If you click <strong>Details</strong>, you will see the graphical list of updates, just like with the <code>gui</code> mode.</li>
<li>Once updates are complete, another notification will appear to say &quot;Pi-Apps updates complete.&quot;</li>
</ul>
</li>
<li><code>cli</code> - This mode is intended to be run in a <strong>terminal</strong>. It checks for updates, lists the updates, and prompts for a Y/N answer.</li>
<li><code>cli-yes</code> - Check for updates, then <strong>automatically apply</strong> them all.</li>
<li><code>set-status</code> - <strong>Check for updates</strong> and then exit.<ul>
<li>The list of updatable <strong>apps</strong> is written to <code>&quot;${DIRECTORY}/data/update-status/updatable-apps&quot;</code>, with the DIRECTORY variable being the location of your Pi-Apps folder. (default: <code>/home/pi/pi-apps</code>)</li>
<li>The list of updatable <strong>files</strong> is written to <code>&quot;${DIRECTORY}/data/update-status/updatable-files&quot;</code>.</li>
<li>The script will exit with code <code>0</code> if updates are available, otherwise <code>1</code>.</li>
</ul>
</li>
<li><code>get-status</code> - Check if an <strong>update <em>was</em> available</strong> the last time <code>set-status</code> was run.<ul>
<li>This is based on the <strong>length</strong> of the <code>updatable-files</code> and <code>updatable-apps</code> files.</li>
<li>Doing it this way allows for an <strong>instant</strong> update-check - necessary for a gui to run quickly. Nobody wants to wait for an update-check to finish before Pi-Apps will launch.</li>
<li>The script will exit with code <code>0</code> if updates are available, otherwise <code>1</code>.</li>
</ul>
</li>
</ul>
<p>Updater also supports a <strong>fast mode</strong>. This is necessary for the Pi-Apps GUI, where you don&#39;t want to wait a few seconds after clicking the &quot;Updates&quot; category. Using the fast mode will rely on the previous update-check. It won&#39;t check for updates, it will simply display them.<br>To use the fast mode:</p>
<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/updater gui fast
</code></pre>
<h2 id="the-api-script">The <code>api</code> script</h2>
<h4 id="location-">Location:</h4>
<p>On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/api</code>. </p>
<h4 id="purpose-">Purpose:</h4>
<p>This script is a collection of <strong>functions</strong> that do various things. Functions are small chunks of bash-code that can be run like a normal command.</p>
<h4 id="usage-">Usage:</h4>
<pre><code class="lang-bash"><span class="hljs-keyword">source</span> ~<span class="hljs-regexp">/pi-apps/</span>api
</code></pre>
<p>You can now run any of the functions inside the api script as if they were real commands.<br>Alternatively, the <code>api</code> script supports running a single function <em>without</em> being sourced:</p>
<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/api apt_lock_wait
</code></pre>
<h4 id="list-of-functions-">List of functions:</h4>
<p>Note: new functions are added often. If you don&#39;t see a function on this list but do see it in the api, please let us know.</p>
<ul>
<li><code>error</code> - display a custom message in red and exit with a return code of <code>1</code>.
Usage:<pre><code><span class="hljs-keyword">error </span>"The command 'sudo apt update' failed!"
</code></pre>This is often seen at the end of a command with the <code>||</code> operator:<pre><code><span class="hljs-attribute">sudo</span> apt update || <span class="hljs-literal">error</span> <span class="hljs-string">"The command 'sudo apt update' failed!"</span>
</code></pre></li>
<li><code>warning</code> - Display a custom message in yellow and prefix it with &quot;WARNING: &quot;.<ul>
<li>Useful for everything where something is wrong but it&#39;s not a fatal error.</li>
<li>This function outputs to <code>stderr</code>.</li>
</ul>
</li>
<li><code>status</code> - Display a custom message in light-blue.<ul>
<li>Used by scripts to indicate current status, like &quot;Downloading...&quot;, &quot;Extracting...&quot;, and &quot;Please wait.&quot;</li>
<li>This function outputs to <code>stderr</code>.</li>
<li>Some scripts don&#39;t want the ending newline, so this function allows for flags to be passed to the <code>echo</code> command. Example usage: <code>status -n &quot;Downloading... &quot;</code></li>
</ul>
</li>
<li><code>status-green</code> - Display a custom message in green.<ul>
<li>Used by scripts to indicate the success of an action, like &quot;Installed FreeCAD successfully&quot;, &quot;Update complete&quot;, and &quot;All packages have been purged successfully.&quot;</li>
<li>This function outputs to <code>stderr</code>.</li>
</ul>
</li>
<li><code>generate_logo</code> - Displays the Pi-Apps logo in a terminal.</li>
<li><code>add_english</code> - Ensures an English locale is installed so that log-diagnosing tools can function properly.<ul>
<li>This was added in <a href="https://github.com/Botspot/pi-apps/pull/1031">PR #1031</a></li>
</ul>
</li>
</ul>
<p>Apt/dpkg/package functions below.</p>
<ul>
<li><code>apt_lock_wait</code> - waits until apt locks are released.</li>
<li><code>package_info</code> - List everything <code>dpkg</code> knows about the specified package.<ul>
<li>This retrieves a block of text from the <code>/var/lib/dpkg/status</code> file.</li>
</ul>
</li>
<li><code>package_installed</code> - determine if the specified package is installed.<ul>
<li>Returns an exit code of <code>0</code> if the package is installed, otherwise it returns <code>1</code>.</li>
</ul>
</li>
<li><code>package_available</code> - determine if the specified package is able to be installed with <code>apt</code>.<ul>
<li>This uses <code>grep</code> to search the <code>/var/lib/apt/lists/</code> folder.</li>
<li>Returns an exit code of <code>0</code> if the package was found, otherwise it returns <code>1</code>.</li>
</ul>
</li>
<li><code>package_dependencies</code> - List the dependencies of a package<ul>
<li>This simply isolates a line from the output of the <code>package_info</code> function.</li>
<li>This is <em>much</em> faster than doing an <code>apt-cache search</code>.</li>
</ul>
</li>
<li><code>less_apt</code> - Reduce the output of an <code>apt</code> operation.<ul>
<li>Example usage:<pre><code class="lang-bash">sudo apt update <span class="hljs-number">2</span>&gt;&amp;<span class="hljs-number">1</span> | less_apt
</code></pre>
</li>
</ul>
</li>
<li><code>apt_update</code> - A wrapper function to run <code>sudo apt update</code>.<ul>
<li>This will wait for apt locks to be released, handle status information, and display helpful tips if packages are upgradable or autoremovable.</li>
<li>Arguments to the function will be passed on to the <code>apt</code> command.</li>
</ul>
</li>
</ul>
<p>Below are three functions that manage <strong>the Pi-Apps local APT repository</strong>.<br>This is a special folder (<code>/tmp/pi-apps-local-packages</code>) used by the <code>install_packages</code> function to handle installing local deb files. Installing local packages from a repository improves dependency-handling, condenses the operation into one <code>apt</code> operation, and allows the packages to be specified in any order.  </p>
<ul>
<li><code>repo_add</code> - Add the specified deb file(s) to the local repository.<ul>
<li>This simply copies specified files to the <code>/tmp/pi-apps-local-packages</code> folder.</li>
</ul>
</li>
<li><code>repo_referesh</code> - Index the local repository, create a <code>Packages</code> file, and a <code>source.list</code>.<ul>
<li>At this point, you can make <code>apt</code> use the repository by passing this flag to it: <code>-o Dir::Etc::SourceList=/tmp/pi-apps-local-packages/source.list</code></li>
</ul>
</li>
<li><code>repo_rm</code> - Removes the local repository.</li>
<li><code>app_to_pkgname</code> - Convert an app-name to an <code>apt</code>-compatible package name.<ul>
<li>This function generates the name to use for creating dummy apt packages. The naming scheme is: <code>pi-apps-XXXXXXXX</code> (each <code>X</code> can be any lowercase letter or number)</li>
<li>View which dummy packages are installed now by running <code>apt search pi-apps-</code> in a terminal.</li>
</ul>
</li>
<li><code>install_packages</code> - Used by apps to install packages.<ul>
<li>This function is replacing the <code>pkg-install</code> script.</li>
<li>Example usage: <code>install_packages package1 /path/to/package2.deb https://example.com/package3.deb package4-* || exit 1</code></li>
<li>First, each argument is analyzed.<ul>
<li>If it&#39;s a URL, the file is downloaded and added to the local repository.</li>
<li>If it&#39;s a deb-file, it&#39;s added to the local repository.</li>
<li>If it contains regex (regular expression, aka the <code>*</code> character), a list of packages is generated using the <code>apt-cache search</code> command.</li>
</ul>
</li>
<li>Next, the local repository is initialized. (if necessary)</li>
<li>Now an <code>apt_update</code> takes place.</li>
<li>It&#39;s time to configure and install an empty apt-package that &quot;depends on&quot; the packages we want to install. We refer to it as a &quot;dummy deb&quot;.<ul>
<li>First the name of the dummy deb is determined, using the <code>app_to_pkgname</code> function.</li>
<li>If the dummy deb is <em>already</em> installed, <code>install_packages</code> will inherit its dependencies and then purge the dummy deb. This means that <strong>the <code>install-packages</code> function can be used multiple times</strong>in an app&#39;s script because it&#39;s accumulative.</li>
<li>The dummy deb is created, packaged, and finally installed.</li>
</ul>
</li>
</ul>
</li>
<li><code>purge-packages</code> - Used by apps to remove packages that they previously installed.<ul>
<li>This function accepts no arguments. It reads the <code>$app</code> variable, purges its associated dummy deb, and autoremoves any packages that are no longer necessary.</li>
</ul>
</li>
<li><code>get_icon_from_package</code> - Given a package (or space-separated list of packages), this function will automatically find the program icon for it.<ul>
<li>This is useful for the <code>createapp</code> script to automatically find a suitable icon for package-apps you&#39;re trying to add.</li>
<li>This uses <code>dpkg-query</code> to list all files each package installed. The list is filteres to only show <code>.png</code> files in <code>/icons/</code> or <code>/pixmaps/</code> folders.</li>
<li>The list is sorted by filesize to find the picture with the most pixels.</li>
</ul>
</li>
</ul>
<p>End of apt functions. App functions below.</p>
<ul>
<li><code>list_apps</code> - List all apps that match a given criteria. (In a newline-separated format)<ul>
<li><code>list_apps local</code> will list apps that exist locally.</li>
<li><code>list_apps</code> is the same as <code>list_apps local</code>.</li>
<li><code>list_apps app</code> will list all apps, both local and online.</li>
<li><code>list_apps installed</code> will list apps that are currently installed.</li>
<li><code>list_apps corrupted</code> will list apps that are currently corrupted.</li>
<li><code>list_apps disabled</code> will list apps that are currently disabled.</li>
<li><code>list_apps uninstalled</code> will list apps that are currently uninstalled.</li>
<li><code>list_apps have_status</code> will list apps that currently have a known status. (A clean Pi-Apps installation won&#39;t have any status files)</li>
<li><code>list_apps missing_status</code> will list apps that don&#39;t have status files.</li>
<li><code>list_apps cpu_installable</code> will list apps that have an installation script compatible with your operating system&#39;s CPU architecture.<ul>
<li>If &quot;app1&quot; only has an <code>install-64</code> script but your system is 32-bit, then &quot;app1&quot; will be excluded from this list.</li>
<li>Likewise, if &quot;app1&quot; only has an <code>install-32</code> script but your system is 64-bit, then &quot;app1&quot; will be excluded from this list.</li>
</ul>
</li>
<li><code>list_apps package</code> will list apps that don&#39;t have scripts but have a <code>packages</code> file.</li>
<li><code>list_apps standard</code> will list apps that do have scripts and don&#39;t have a <code>packages</code> file.</li>
<li><code>list_apps hidden</code> will list apps that are in the special &quot;hidden&quot; category.</li>
<li><code>list_apps visible</code> will list apps that are <strong>not</strong> in the special &quot;hidden&quot; category.</li>
<li><code>list_apps online</code> will list apps that exist in the <code>update/pi-apps/apps</code> folder.</li>
<li><code>list_apps online_only</code> will list apps that are <strong>only</strong> in the <code>update/pi-apps/apps</code> folder.</li>
<li><code>list_apps local_only</code> will list apps that are <strong>not</strong> in the <code>update/pi-apps/apps</code> folder.</li>
</ul>
</li>
<li><code>list_intersect</code> - Takes two lists of apps and <em>intersects</em> them, meaning that only apps that are listed in <strong>both</strong> lists are returned.
For example, this will show apps that are both cpu_installable and visible:<pre><code>list_apps cpu_installable <span class="hljs-string">| list_intersect "</span>$(list_apps visible)<span class="hljs-string">"</span>
</code></pre></li>
<li><code>list_subtract</code> - Takes two lists of apps and <em>subtracts</em> one from other, meaning that only apps listed in the first list and <strong>not</strong> in the second list, are returned.
For example, this will show apps that are <em>not</em> compatible with your system&#39;s architecture:<pre><code>list_apps <span class="hljs-built_in">local</span> | list_subtract <span class="hljs-string">"<span class="hljs-variable">$(list_apps cpu_installable)</span>"</span>
</code></pre></li>
<li><code>read_category_files</code> - Generates a list of categories; data compiled from the <code>data/category-overrides</code> and <code>etc/categories</code> files, with added support for unlisted apps.</li>
<li><p><code>app_categories</code> - Format the categories file, then list all apps, as if they were inside folders, based on the categories file. Also lists all apps under special &quot;Installed&quot; and &quot;All Apps&quot; categories.</p>
</li>
<li><p><code>bitly_link</code> - Increase/decrease the &quot;number of users&quot; a certain app has.</p>
<ul>
<li>Botspot creates <a href="https://bitly.com">bitly</a> links for every app: one link for installing it, and one link for uninstalling it.</li>
<li>Bitly will track how many times each link has been clicked.</li>
<li>Assuming the &quot;Enable Analytics&quot; setting was not turned off, this function will &quot;click&quot; one of those links.</li>
<li>Botspot uses a script to upload bitly&#39;s statistics to the <a href="https://github.com/Botspot/pi-apps-analytics">pi-apps-analytics</a> repository.</li>
</ul>
</li>
<li><code>usercount</code> - returns the number of users an app has, based on the current number in the <a href="https://github.com/Botspot/pi-apps-analytics">pi-apps-analytics</a> repository.
To display the number of users for the Arduino app:<pre><code><span class="hljs-attribute">usercount Arduino</span>
</code></pre></li>
<li><code>script_name</code> - returns name of install script(s) for the specified app. Possible outputs: &#39;&#39;, &#39;install&#39;, &#39;install-32&#39;, &#39;install-64&#39;, &#39;install-32 install-64&#39;
Usage:<pre><code><span class="hljs-keyword">script_name </span>Arduino
</code></pre></li>
<li><code>script_name_cpu</code> - Given an app, this returns the name of the app&#39;s installation script that would be run if you ran it.<ul>
<li>For example, if your operating system is 32-bit and the app has an <code>install-32</code> script, this function would return &quot;install-32&quot;.</li>
<li>If your operating system is 64-bit and the app has an <code>install-64</code> script, this function would return &quot;install-64&quot;.</li>
<li>If the app has an <code>install</code> script, this function would return &quot;install&quot;.</li>
<li>If none of the above, don&#39;t return anything.</li>
</ul>
</li>
<li><code>app_status</code> - return the given app&#39;s current status.<ul>
<li>If the app&#39;s status file does not exist, this function returns &#39;uninstalled&#39;.</li>
<li>Otherwise, this function returns the contents of the app&#39;s status file.</li>
</ul>
</li>
<li><code>app_type</code> - Determine if an app is a <code>standard</code> app or if it&#39;s a <code>package</code>.</li>
<li><code>will_reinstall</code> - Return an exit code of <code>0</code> if the specified app would be reinstalled during an update, otherwise return an exit code of <code>1</code>.<ul>
<li>If the app&#39;s existing installation script is not identical to the new version of the installation script, AND the app is currently installed, exit with a code of <code>0</code>, otherwise exit <code>1</code>.</li>
</ul>
</li>
<li><code>app_search</code> - Search all apps for the specified search query.<ul>
<li>In each app-folder, this will search for matches in the following files:<ul>
<li><code>description</code></li>
<li><code>credits</code></li>
<li><code>website</code></li>
</ul>
</li>
<li>It hides incompatible and invisible apps before displaying the results. (list of app names, one per line)</li>
</ul>
</li>
<li><code>app_search_gui</code> - A graphical front-end for the <code>app_search</code> function.<ul>
<li>This displays all results from <code>app_search</code> in a graphical list.</li>
<li>One app should be selected from the list before clicking OK.<ul>
<li>If only one app is displayed in the list, no need to select it.</li>
</ul>
</li>
<li>The chosen app (if any) is returned.</li>
</ul>
</li>
<li><code>generate_app_icons</code> - Resize a specified image and place the icons in the specified app-folder.<ul>
<li>This requires imagemagick to be installed. If it&#39;s missing, a dialog box will appear and ask permission to install it.</li>
<li>Example usage: <code>generate_app_icons /path/to/my-image.png my-app</code></li>
</ul>
</li>
<li><code>refresh_pkgapp_status</code> - For the specified package-app, if dpkg thinks it&#39;s installed, then mark it as installed.</li>
<li><code>refresh_all_pkgapp_status</code> - For every package-app, if dpkg thinks it&#39;s installed, then mark it as installed.</li>
</ul>
<p>Logfile functions below.</p>
<ul>
<li><code>get_logfile</code> - Find the most recent logfile for the specified app.</li>
<li><code>log_diagnose</code> - Search a specified logfile for phrases that indicate non-errors.<ul>
<li>Many errors are not Pi-Apps&#39;s fault. Most are outside of Pi-Apps&#39;s control, but caused by user-interference, Internet problems, or apt configuration errors.</li>
<li>Errors are categorized into three types: <code>system</code>, <code>internet</code>, <code>package</code>, and unknown.<ul>
<li>If a known phrase is identified, the <code>$error_type</code> variable is set to either <code>system</code> or <code>internet</code> or <code>package</code>.</li>
<li>If no phrases were identified, the <code>$error_type</code> variable will be set to <code>unknown</code>. Only when the error_type is &quot;unknown&quot; will Pi-Apps allow the user to send an error report.</li>
</ul>
</li>
<li>Each detected error has an accompanying caption for the user to read. This caption explains what the problem is and how to fix it.<ul>
<li>As multiple error messages might be identified, the error captions are stored in an <strong>array</strong> variable called <code>$error_caption</code>. Storing explanations in an array allows multiple explanations to be displayed to the user.</li>
</ul>
</li>
<li>Before exiting, this function returns the collected information. The first line is the value of <code>$error_type</code>, while subsequent lines are the value(s) of <code>$error_caption</code>.</li>
</ul>
</li>
<li><code>format_logfile</code> - Log files store the entire output of all apps being installed or uninstalled. This function formats the logfile to improve its readability.<ul>
<li>Unwanted patterns are removed, like terminal color-codes, long arrays of periods, etc.</li>
<li>All instances of the <code>\r</code> character are replaced by the <code>\n</code> character.</li>
<li>A header is added to the file, containing the output from <code>get_device_info</code>.</li>
</ul>
</li>
<li><code>send_error_report</code> - Sends a log file to the Pi-Apps developers.</li>
<li><code>send_error_report_gui</code> - A graphical front-end for <code>send_error_report</code> - asks the user permission before sending an error log.<ul>
<li>Please note that this is currently not being used. The <code>manage</code> script has its own error-reporting gui and directly uses <code>send_error_report</code>.</li>
</ul>
</li>
</ul>
<p>Below are all functions that don&#39;t have anything to do with apps.</p>
<ul>
<li><code>runonce</code> - this function runs code only once, ever. Used by other scripts to run one-time workarounds to ensure a smooth transition as Pi-Apps evolves.<ul>
<li>For example, this is a real usage of <code>runonce</code> in the Pi-Apps <code>gui</code> script:<pre><code class="lang-bash"><span class="hljs-comment">#ensure curl is installed</span>
runonce &lt;&lt;<span class="hljs-string">"EOF"</span>
  <span class="hljs-keyword">if</span> ! <span class="hljs-built_in">command</span> -v curl &gt;/dev/null ;<span class="hljs-keyword">then</span>
    sudo apt install -y curl
  <span class="hljs-keyword">fi</span>
EOF
</code></pre>
It installs <code>curl</code> on the system, but only tries once.</li>
<li>This works by hashing the entire command first, using <code>sha256sum</code>.</li>
<li>If the hash matches a line in the <code>data/runonce_hashes</code> file, nothing occurs. Otherwise, the command is executed.</li>
</ul>
</li>
<li><code>text_editor</code> - Use a text editor to open a file.<ul>
<li>This obeys your choice of &quot;Preferred text editor&quot;.
Usage:<pre><code>text_editor /path/<span class="hljs-keyword">to</span>/your.<span class="hljs-built_in">file</span>
</code></pre></li>
</ul>
</li>
<li><code>view_file</code> - Display a maximized <code>yad</code> window to view a file. This is used to view logfiles.</li>
<li><code>is_supported_system</code> - determines if your operating system is supported. This returns an exit-code of <code>0</code> if supported, otherwise<code>1</code>.
If any of the below criteria are true, then your system is unsupported:<ul>
<li>The kernel matches &quot;x86&quot; or &quot;i686 or &quot;i386&quot;.</li>
<li>The <code>/proc/version</code> file matches &quot;Android&quot;.</li>
<li>The operating system&#39;s <code>PRETTY_NAME</code> matches &quot;stretch&quot;, &quot;wheezy&quot;, &quot;jessie&quot;, &quot;manjaro&quot; or &quot;Ubuntu 16&quot;.</li>
<li>The kernel matches &quot;armv6*&quot;.</li>
<li>The script is being run as <code>root</code>.</li>
<li>The system has less than 500MB of free space.</li>
</ul>
</li>
<li><code>get_device_info</code> - summarizes the current system setup for debug use.<ul>
<li>To view the output on your  system, run this command:<pre><code>~/<span class="hljs-literal">pi</span>-apps/api get_device_info
</code></pre></li>
<li>This function is used in the <code>format_log_file</code> function.</li>
</ul>
</li>
<li><code>functions_to_files</code> - Takes every function in the <code>api</code> and turns them into their own miniature bash scripts.<ul>
<li>This exists purely for developer-convenience. It allows you to handle functions as if they were files.</li>
<li>It creates a folder (<code>~/pi-apps/function-files</code>) and then places files in it.</li>
</ul>
</li>
<li><code>files_to_functions</code> - Takes every file in the <code>function-files</code> folder and re-combines them.<ul>
<li>The resulting output is printed to the terminal.</li>
</ul>
</li>
</ul>
<p>Command interceptors below:</p>
<ul>
<li><code>git_clone</code> - Wrapper function for the <code>git clone</code> command with improvements:<ul>
<li>Status information is displayed. (&quot;Downloading XXXXXX repository...&quot;)</li>
<li><code>git</code>&#39;s output is suppressed. But if the operation fails, its full output will be displayed in the error message.</li>
<li>Before cloning the repo, the destination folder is removed. This prevents the common error &quot;<code>Fatal: destination path &#39;XXXXXX&#39; already exists and is not an empty directory.</code>&quot;.</li>
<li>There may be times when an app-script doesn&#39;t want the output suppressed, or status information, or the folder removed first. That&#39;s why this function is an &quot;opt-in&quot; function; script-writers have to consciencely switch to <code>git_clone</code> if they want to.</li>
</ul>
</li>
<li><code>wget</code> - This function overrides the <code>wget</code> command in all app-scripts. To speed up app-installation, it uses the <code>aria2c</code> tool when possible. Aria2c is faster and more reliable than wget, but it can&#39;t be used in all situations.<ul>
<li>To determine if <code>aria2c</code> can be used, this function parses all flags given to it. It stores the url and the output filename.<ul>
<li>If any flags other than <code>-q</code>, <code>-O</code>, and <code>-qO</code> are passed, <code>wget</code> is used.</li>
<li>If the <code>aria2c</code> command does not exist, <code>wget</code> is used.</li>
<li>If the output is not a file but is being sent to <code>stdout</code> (using the <code>-qO-</code> flag, for example), <code>wget</code> is used.</li>
</ul>
</li>
<li>If <code>aria2c</code> is enabled, it runs with the following flags:
<code>-c -x 16 -s 16 -m 10 --retry-wait 30 --console-log-level=error --show-console-readout=false --summary-interval=0 &quot;$url&quot; --dir &#39;/&#39; -o &quot;${file:1}&quot; --allow-overwrite</code><ul>
<li>If the <code>-q</code> flag was passed, the <code>--quiet</code> flag is sent to aria2c.</li>
</ul>
</li>
<li>Otherwise, if aria2c was ruled out, <code>wget</code> is run as it normally would.</li>
<li>This function is designed to operate seamlessly in 100% of cases. App-developers <em>should not have to even know</em> that this function is really translating <code>wget</code> commands to <code>aria2c</code> - it should operate exactly the same as <code>wget</code>, but faster.</li>
</ul>
</li>
<li><code>chmod</code> - Wrapper function for the <code>chmod</code> command with status information.<ul>
<li>This displays &quot;<code>Making executable: /path/to/file</code>&quot;.</li>
</ul>
</li>
<li><code>unzip</code> - Wrapper function for the <code>unzip</code> command with status information.<ul>
<li>This displays &quot;<code>Extracting: /path/to/file</code>&quot;.</li>
</ul>
</li>
</ul>
<p>And with that, we come to the end of functions in the <code>api</code> script. If you see a function that&#39;s not listed here, please let us know.</p>
<h2 id="the-gui-script">The <code>gui</code> script</h2>
<h4 id="location-">Location:</h4>
<p>On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/gui</code>. </p>
<h4 id="purpose-">Purpose:</h4>
<p>This script handles Pi-Apps&#39;s entire user-interface.</p>
<h4 id="usage-">Usage:</h4>
<p>To run Pi-Apps: </p>
<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/gui
</code></pre>
<p>To start Pi-Apps at a specific app:</p>
<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/gui Arduino
</code></pre>
<p>To start Pi-Apps on a specific category:</p>
<pre><code class="lang-bash">~<span class="hljs-regexp">/pi-apps/gui</span> <span class="hljs-string">'All Apps/'</span>
</code></pre>
<h4 id="how-it-works-">How it works:</h4>
<ol>
<li>The splash screen appears.</li>
<li>The <code>api</code> script is sourced.</li>
<li>The pi-apps logo is displayed in the terminal (using the <code>generate_logo</code> function)</li>
<li>A series of <code>runonce</code> entries are executed in the background.</li>
<li>The message of the day is determined.<ul>
<li>To save time, it&#39;s stored in <code>data/announcements</code>.</li>
<li>If that file is missing or it&#39;s more than a day old, it is downloaded from <a href="https://github.com/Botspot/pi-apps-announcements">the pi-apps-announcements repository</a>.</li>
<li>One random line is taken from the file and used as the message for this session.</li>
</ul>
</li>
<li>We now come to a <code>while</code> loop that runs the GUI. Inside is an <code>if</code> statement that obeys the following values of the <code>$action</code> variable:<ul>
<li><code>main-window</code> - Handles the app list.<ul>
<li>This may be a yad window or an xlunch window, depending on the &quot;App List Style&quot; setting.</li>
<li>Xlunch is compiled, if necessary.</li>
</ul>
</li>
<li><code>details</code> - Displays the details of the current app.</li>
<li><code>search</code> - Sets the <code>$app</code> variable to the output of the <code>app_search_gui</code> function.</li>
<li>The rest of the modes need no explanation. They are: <code>exit</code>, <code>back</code>, <code>install</code>, <code>uninstall</code>, <code>scripts</code>, <code>edit</code>, <code>credits</code>, <code>enable</code>, <code>viewlog</code>, <code>mind-reading</code>, <code>view-updates</code>, <code>unknown</code>.<h2 id="the-createapp-script">The <code>createapp</code> script</h2>
<h4 id="location-">Location:</h4>
On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/createapp</code>. <h4 id="purpose-">Purpose:</h4>
A GUI to help you create/edit an app. <h4 id="usage-">Usage:</h4>
To create a new app:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/createapp
</code></pre>
To edit an existing app:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/createapp Arduino
</code></pre>
<h4 id="how-it-works-">How it works:</h4>
This script is one long <code>while</code> loop with a <code>case</code> statement for each step. (similar to the <code>gui</code> script)<br>Each dialog allows you to go forward or backward and the current step is stored in the <code>$step</code> variable.<br>That&#39;s about it. View the script to see how each step works.<h2 id="the-settings-script">The <code>settings</code> script</h2>
<h4 id="location-">Location:</h4>
On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/settings</code>. <h4 id="purpose-">Purpose:</h4>
To manage settings for Pi-Apps.<h4 id="usage-">Usage:</h4>
To launch the graphical settings window:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/settings
</code></pre>
To check for missing setting-values and fill them with the default values, use this flag:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/settings refresh
</code></pre>
To revert all settings to their default values:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/settings revert
</code></pre>
<h4 id="how-it-works-">How it works:</h4>
Each setting is stored in <em>two</em> places in the main pi-apps folder:</li>
</ul>
</li>
<li>The setting&#39;s possible values, default value, and explanation is stored in the <code>etc/setting-params</code> folder.<ul>
<li>For example, the <code>etc/setting-params/App List Style</code> file contains:<pre><code><span class="hljs-comment">#Pi-Apps can display the apps as a compact list (yad), or as a group of larger icons. (xlunch)</span>
<span class="hljs-attribute">yad</span>
xlunch-dark
xlunch-dark-<span class="hljs-number">3d</span>
xlunch-light-<span class="hljs-number">3d</span>
</code></pre></li>
<li>All commented lines are the explanation, also known as the tooltip.<ul>
<li>For this file, it is:<pre><code>#<span class="hljs-type">Pi</span>-<span class="hljs-type">Apps</span> can display the apps <span class="hljs-keyword">as</span> a compact <span class="hljs-built_in">list</span> (yad), <span class="hljs-keyword">or</span> <span class="hljs-keyword">as</span> a group <span class="hljs-keyword">of</span> larger icons. (xlunch)
</code></pre></li>
</ul>
</li>
<li>The first uncommented line is the default value for the setting.<ul>
<li>For this file, it is:<pre><code><span class="hljs-attribute">yad</span>
</code></pre></li>
</ul>
</li>
<li>Subsequent uncommented lines are additional possible values.<ul>
<li>For this file, they are:<pre><code>xlunch-dark
xlunch-dark<span class="hljs-number">-3d</span>
xlunch-light<span class="hljs-number">-3d</span>
</code></pre></li>
</ul>
</li>
</ul>
</li>
<li>The setting&#39;s current value is stored in the <code>data/settings</code> folder. This is a single file that contains a single-line value.<ul>
<li>For example, if I set the app list style to &quot;xlunch-dark-3d&quot;, the <code>data/settings/App List Style</code> file will contain &quot;<code>xlunch-dark-3d</code>&quot;.</li>
</ul>
</li>
</ol>
<p>This dual-file/dual-folder approach is necessary to retain your choice, while allowing there to be future updates to settings, and/or their possible values. (Remember, the <code>data</code> directory is never updated but the <code>etc</code> folder is.)</p>
<h2 id="the-preload-script">The <code>preload</code> script</h2>
<h4 id="location-">Location:</h4>
<p>On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/preload</code>. </p>
<h4 id="purpose-">Purpose:</h4>
<p>To generate the app-list for a given category, and prioritizing minimum execution-time.</p>
<h4 id="usage-">Usage:</h4>
<p>To generate the app-list of the &quot;Installed&quot; category for yad:</p>
<pre><code class="lang-bash">~<span class="hljs-regexp">/pi-apps/</span>preload yad <span class="hljs-string">'Installed'</span>
</code></pre>
<p>To generate the app-list for xlunch for the main page (no category)</p>
<pre><code class="lang-bash">~<span class="hljs-regexp">/pi-apps/</span>preload <span class="hljs-regexp">/home/</span>pi<span class="hljs-regexp">/pi-apps/</span>preload xlunch <span class="hljs-string">''</span>
</code></pre>
<h4 id="how-it-works-">How it works:</h4>
<p>This script is designed for maximum speed. As a result, it uses many tricks to run faster.</p>
<ol>
<li>Compile the <code>genapplist-yad</code> program. This is a C program designed to improve preloading times, but if it fails, a bash-based fallback is used.<ul>
<li>It uses <code>gcc</code> to compile the <code>/etc/genapplist-yad.c</code>file to the <code>/etc/genapplist-yad</code> binary.</li>
<li>This program is tested; if it fails to produce 5 lines of output for one input app, the program is deleted to use the bash-based fallback.</li>
</ul>
</li>
<li>Determine if it&#39;s <strong>necessary</strong> to generate the app-list.<ul>
<li>If nothing has been modified in the <code>apps</code> folder, the <code>settings</code> folder, the <code>update-status</code> folder, the <code>etc</code> folder, the <code>api</code> script, the <code>preload</code> script, and the <code>categories</code> file, <strong>skip</strong> generating the app-list, <strong>return the contents</strong> of the previous app-list in the <code>data/preload</code> folder, and <strong>exit</strong>.</li>
</ul>
</li>
<li>If it is necessary to generate the app-list, use the <code>app_categories</code> function to generate a list of all apps in their respective categories.</li>
<li>Limit the list of apps to the current category. (so if we&#39;re viewing the &quot;Installed&quot; category, hide all apps that are not in there.)</li>
<li>If the &quot;Shuffle App list&quot; setting is enabled, shuffle the list of apps and categories now.<ul>
<li>Note: categories are always displayed above apps.</li>
</ul>
</li>
<li>Remove apps that are not compatible with the operating system&#39;s CPU architecture.</li>
<li>Generate the list of visible categories.</li>
<li>Generate the list of visible apps.<ul>
<li>If the GUI-mode is yad, use the <code>genapplist-yad</code> program if it exists.</li>
<li>Otherwise, generate the list of apps the slower bash-based way.</li>
</ul>
</li>
<li>Save the resulting app-list to a file in the <code>data/preload</code> folder. (so that next time <code>preload</code> is run, it might not have to generate anything)</li>
<li>In the background, place all app-icons in the disk cache. This improves load-time.</li>
<li>Output the resulting app-list.</li>
<li>Run the <code>preload-daemon</code> script in the background to preload other categories. That way, when using Pi-Apps, by the time you click any category, it has just been preloaded and is ready-to-go.<h2 id="the-preload-daemon-script">The <code>preload-daemon</code> script</h2>
<h4 id="location-">Location:</h4>
On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/etc/preload-daemon</code>.<br>This file is located in the <code>etc</code> folder because it&#39;s one of the smaller scripts.<h4 id="purpose-">Purpose:</h4>
To generate the app-list for all categories.<h4 id="usage-">Usage:</h4>
Preload all categories for <code>yad</code>, repeating every 30 seconds for a total of 20 times:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/etc/preload-daemon yad
</code></pre>
Preload all categories for <code>xlunch</code> only once:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/etc/preload-daemon xlunch once
</code></pre>
<h2 id="the-terminal-run-script">The <code>terminal-run</code> script</h2>
<h4 id="location-">Location:</h4>
On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/etc/terminal-run</code>.<br>This file is located in the <code>etc</code> folder because it&#39;s one of the smaller scripts.<h4 id="purpose-">Purpose:</h4>
This script may be Botspot&#39;s <em>greatest contribution to the open-source world</em>. Apart from this script, there is no reliable way to:</li>
<li>Run a <em>newline-separated</em> list of commands in a new terminal window.</li>
<li>Set the terminal&#39;s title, as desired.</li>
<li>Keep the script running until the terminal has been closed.</li>
<li>Support a variety of terminals.<h4 id="usage-">Usage:</h4>
This command will run two commands in a terminal and set the terminal&#39;s title to &quot;Upgrading your packages&quot;:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/etc/terminal-<span class="hljs-built_in">run</span> 'sudo apt update
sudo apt upgrade' <span class="hljs-string">"Upgrading your packages"</span>
</code></pre>
The <code>terminal-run</code> script will not exit until the terminal closes.<h4 id="how-it-works-">How it works:</h4>
As mentioned earlier, this script supports running a <strong><em>list</em></strong> of commands in a terminal. That may sound easy enough, but it&#39;s not.</li>
<li>Terminals are not designed to support this. Most terminals can, with some clever tricks, but it varies on a case-by-case basis.</li>
</ol>
<p>As mentioned earlier, this script will keep running until the terminal has been closed. How is that possible?</p>
<ul>
<li>Before running any commands in a terminal, a special file is created in the <code>/tmp</code> folder. This file is empty for now.</li>
<li>Then, the terminal is instructed to write its PID (process ID) <em>to the file</em>.</li>
<li>Now, while the terminal is running, the <code>terminal-run</code> script can regularly check if that PID process is still running.<ul>
<li>It does this by periodically checking if the <code>/proc/${PID}</code> folder exists.</li>
</ul>
</li>
<li>When the PID stops, it indicates that the terminal has been closed. Now the <code>terminal-run</code> script exits.</li>
</ul>
<p>Supported terminals:</p>
<ul>
<li>lxterminal</li>
<li>xfce4-terminal</li>
<li>mate-terminal</li>
<li>xterm</li>
<li>konsole</li>
<li>terminator</li>
<li>gnome-terminal</li>
<li>x-terminal-emulator</li>
</ul>
<p>Debug mode: if you set the <code>DEBUG</code> variable to <code>1</code>, <code>terminal-run</code> will output the name of the currently-used terminal.</p>
<ul>
<li>This is useful for debugging, when no terminal appears and we want to know which terminal was being used.<h2 id="the-categoryedit-script">The <code>categoryedit</code> script</h2>
<h4 id="location-">Location:</h4>
On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/etc/categoryedit</code>.<br>This file is located in the <code>etc</code> folder because it&#39;s one of the smaller scripts.<h4 id="purpose-">Purpose:</h4>
Manage Pi-Apps categories.<br>As of commit <a href="https://github.com/Botspot/pi-apps/commit/ab1fcb5a114ab720df1712aaf151a9733e18a94c">https://github.com/Botspot/pi-apps/commit/ab1fcb5a114ab720df1712aaf151a9733e18a94c</a>, there are <em>two</em> categories files: a local one and a global one. The global file is kept updated like any other file, while the local file is empty by default but can contain <strong>overrides</strong>.<br>The global categories file: <code>/home/pi/pi-apps/etc/categories</code><br>The local categories file: <code>/home/pi/pi-apps/data/category-overrides</code>  <h4 id="usage-">Usage:</h4>
Run the category editor:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/etc/categoryedit
</code></pre>
Move the Arduino app to the Internet category:<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/etc/categoryedit Arduino Internet
</code></pre>
Move the Arduino app to the top level (no category):<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/etc/categoryedit Arduino
</code></pre>
<h2 id="the-logviewer-script">The <code>logviewer</code> script</h2>
<h4 id="location-">Location:</h4>
On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/etc/logviewer</code>.<br>This file is located in the <code>etc</code> folder because it&#39;s one of the smaller scripts.<h4 id="purpose-">Purpose:</h4>
Browse the list of log files, opening any files that you click on with the <code>viewlog</code> script.<h4 id="usage-">Usage:</h4>
<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/etc/logviewer
</code></pre>
<h2 id="the-viewlog-script">The <code>viewlog</code> script</h2>
<h4 id="location-">Location:</h4>
On a default pi-apps installation, you will find this script at <code>/home/pi/pi-apps/etc/viewlog</code>.<br>This file is located in the <code>etc</code> folder because it&#39;s one of the smaller scripts.<h4 id="purpose-">Purpose:</h4>
View the specified log file in a text editor.<h4 id="usage-">Usage:</h4>
<pre><code class="lang-bash">~/<span class="hljs-literal">pi</span>-apps/etc/viewlog ~/<span class="hljs-literal">pi</span>-apps/logs/install-success-Arduino.<span class="hljs-built_in">log</span>
</code></pre>
Notes:</li>
<li>This script will kill previous instances of itself.</li>
<li>This script <strong>does not obey</strong> the &quot;Preferred text editor&quot; setting.<ul>
<li>Why? Viewing a log in <strong><em><code>geany</code></em></strong> (the default &quot;Preferred text editor&quot; setting) is cumbersome and breaks the whole concept of closing the editor once you click on a new logfile.</li>
</ul>
</li>
</ul>
</body></html>